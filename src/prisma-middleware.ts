import { generateKSUID } from "./util/ksuid";

/**
 * Prisma-compatible MiddlewareParams type (without importing @prisma/client).
 * This interface defines the structure of parameters that Prisma passes to middleware functions.
 */
interface MiddlewareParams {
  /**
   * The name of the model being operated on (e.g., "User", "Product").
   * May be undefined for operations that don't target a specific model.
   */
  model?: string;

  /**
   * The type of database operation being performed.
   * Common values include: "create", "createMany", "update", "delete", "findUnique", etc.
   */
  action: string;

  /**
   * Arguments for the database operation, including data to be written.
   * For create operations, this contains the record data.
   * For createMany, this contains an array of records.
   */
  args: {
    /**
     * Data to be written to the database.
     * Can be a single object (for create) or an array of objects (for createMany).
     */
    data?: Record<string, unknown> | Record<string, unknown>[];

    /**
     * Any other arguments passed to the Prisma client method.
     */
    [key: string]: unknown;
  };

  /**
   * Path to the current data being processed in nested operations.
   */
  dataPath?: string[];

  /**
   * Indicates if the operation is running within a transaction.
   */
  runInTransaction?: boolean;
}

/**
 * A Prisma-compatible middleware function signature.
 *
 * @param params - The parameters for the current database operation
 * @param next - Function to call the next middleware or execute the database operation
 * @returns Promise resolving to the operation result
 */
type Middleware = (
  params: MiddlewareParams,
  next: (params: MiddlewareParams) => Promise<unknown>,
) => Promise<unknown>;

/**
 * A map of model names to prefix strings.
 *
 * Used to define which prefix should be applied to KSUIDs for each model.
 * Example: { User: "usr_", Product: "prod_" }
 */
type PrefixMap = Record<string, string>;

/**
 * A function type that generates a prefix string based on the provided model name.
 *
 * This allows for dynamic prefix generation when a static mapping isn't sufficient.
 *
 * @param model - The name of the model to generate a prefix for
 * @returns A string prefix to use for the model's KSUIDs
 */
type PrefixGenerator = (model: string) => string;

/**
 * Options for creating KSUID middleware.
 */
interface KsuidMiddlewareOptions {
  /**
   * A mapping of model names to their KSUID prefixes.
   * Example: { User: "usr_", Product: "prod_" }
   */
  prefixMap: PrefixMap;

  /**
   * Optional function to dynamically generate prefixes for models not found in prefixMap.
   * If provided, this will be called when a model doesn't have a prefix defined in prefixMap.
   */
  prefixFn?: PrefixGenerator;
}

/**
 * Creates a Prisma middleware that automatically generates KSUIDs for model IDs.
 *
 * This middleware intercepts 'create' and 'createMany' operations and adds KSUIDs
 * to records that don't already have an ID defined. Each KSUID is prefixed based
 * on the model name, using either a predefined prefix from prefixMap or one
 * generated by the optional prefixFn.
 *
 * @example
 * ```typescript
 * // Basic usage with static prefixes
 * const middleware = createKsuidMiddleware({
 *   prefixMap: { User: "usr_", Product: "prod_" }
 * });
 *
 * // With dynamic prefix generation
 * const middleware = createKsuidMiddleware({
 *   prefixMap: { User: "usr_" },
 *   prefixFn: (model) => model.toLowerCase().substring(0, 4) + "_"
 * });
 *
 * // Apply to Prisma client
 * prisma.$use(middleware);
 * ```
 *
 * @param options - Configuration options for the middleware
 * @returns A Prisma middleware function that adds KSUIDs to records
 * @throws Error if prefixMap is invalid or if a prefix is not defined for a model
 */
export const createKsuidMiddleware = (
  options: KsuidMiddlewareOptions,
): Middleware => {
  const { prefixMap, prefixFn } = options;

  // Validate that prefixMap is provided and is an object
  if (!prefixMap || typeof prefixMap !== "object") {
    throw new Error("A valid prefixMap must be provided.");
  }

  return async (params, next) => {
    const model = params.model || "";

    // Try to get prefix from the prefixMap first
    let prefix: string | undefined = prefixMap[model];

    // If no prefix found in map but a prefix function is provided,
    // use the function to generate a prefix
    if (!prefix && prefixFn) {
      prefix = prefixFn(model);
    }

    // Validate that we have a non-empty prefix for this model
    // This ensures consistent ID formatting and prevents errors from undefined prefixes
    if (!prefix || prefix.length === 0) {
      throw new Error(`Prefix not defined or invalid for model "${model}".`);
    }

    // Handle 'create' operations by adding an ID to the data object
    // if one doesn't already exist
    if (params.action === "create" && params.args.data) {
      const data = params.args.data as Record<string, unknown>;

      // Only add an ID if data is an object and doesn't already have an ID
      if (typeof data === "object" && !Array.isArray(data) && !data.id) {
        data.id = generateKSUID(prefix);
      }
    }

    // Handle 'createMany' operations by adding IDs to each item in the data array
    // that doesn't already have an ID
    if (params.action === "createMany" && Array.isArray(params.args.data)) {
      params.args.data = params.args.data.map(
        (item: Record<string, unknown>) => {
          // Only add an ID if the item is an object and doesn't already have an ID
          if (typeof item === "object" && !item.id) {
            item.id = generateKSUID(prefix);
          }
          return item;
        },
      );
    }

    // Continue the middleware chain or execute the operation
    return next(params);
  };
};
